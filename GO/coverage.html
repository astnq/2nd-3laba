
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>datastructures: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">datastructures/BinaryTree.go (98.0%)</option>
				
				<option value="file1">datastructures/DoublyLinkedList.go (97.7%)</option>
				
				<option value="file2">datastructures/HashTable.go (95.6%)</option>
				
				<option value="file3">datastructures/Serialization.go (85.7%)</option>
				
				<option value="file4">datastructures/SinglyLinkedList.go (89.6%)</option>
				
				<option value="file5">datastructures/array.go (96.6%)</option>
				
				<option value="file6">datastructures/main.go (0.0%)</option>
				
				<option value="file7">datastructures/stack.go (86.4%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package main

import (
        "fmt"
        "strings"
)

type TreeNode struct {
        data  int
        left  *TreeNode
        right *TreeNode
}

type FullBinaryTree struct {
        root *TreeNode
}

func NewFullBinaryTree() *FullBinaryTree <span class="cov8" title="1">{
        return &amp;FullBinaryTree{}
}</span>

func (b *FullBinaryTree) Insert(value int) <span class="cov8" title="1">{
        b.root = b.insert(b.root, value)
}</span>

func (b *FullBinaryTree) insert(node *TreeNode, value int) *TreeNode <span class="cov8" title="1">{
        if node == nil </span><span class="cov8" title="1">{
                return &amp;TreeNode{data: value}
        }</span>
        <span class="cov8" title="1">if value &lt; node.data </span><span class="cov8" title="1">{
                node.left = b.insert(node.left, value)
        }</span> else<span class="cov8" title="1"> {
                node.right = b.insert(node.right, value)
        }</span>
        <span class="cov8" title="1">return node</span>
}

func (b *FullBinaryTree) Print() <span class="cov8" title="1">{
        b.printTree(b.root, 0)
}</span>

func (b *FullBinaryTree) printTree(node *TreeNode, depth int) <span class="cov8" title="1">{
        if node == nil </span><span class="cov8" title="1">{
                return
        }</span>
        <span class="cov8" title="1">b.printTree(node.right, depth+1)
        fmt.Printf("%s%d\n", strings.Repeat("    ", depth), node.data)
        b.printTree(node.left, depth+1)</span>
}

func (b *FullBinaryTree) PrintZigZag() <span class="cov8" title="1">{
        if b.root == nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">currentLevel := []*TreeNode{b.root}
        nextLevel := []*TreeNode{}
        leftToRight := true

        for len(currentLevel) &gt; 0 </span><span class="cov8" title="1">{
                node := currentLevel[len(currentLevel)-1]
                currentLevel = currentLevel[:len(currentLevel)-1]

                if node != nil </span><span class="cov8" title="1">{
                        fmt.Printf("%d ", node.data)
                        if leftToRight </span><span class="cov8" title="1">{
                                if node.left != nil </span><span class="cov8" title="1">{
                                        nextLevel = append(nextLevel, node.left)
                                }</span>
                                <span class="cov8" title="1">if node.right != nil </span><span class="cov8" title="1">{
                                        nextLevel = append(nextLevel, node.right)
                                }</span>
                        } else<span class="cov8" title="1"> {
                                if node.right != nil </span><span class="cov8" title="1">{
                                        nextLevel = append(nextLevel, node.right)
                                }</span>
                                <span class="cov8" title="1">if node.left != nil </span><span class="cov8" title="1">{
                                        nextLevel = append(nextLevel, node.left)
                                }</span>
                        }
                }

                <span class="cov8" title="1">if len(currentLevel) == 0 </span><span class="cov8" title="1">{
                        fmt.Println()
                        currentLevel, nextLevel = nextLevel, currentLevel
                        leftToRight = !leftToRight
                }</span>
        }
}

func (b *FullBinaryTree) IsEmpty() bool <span class="cov8" title="1">{
        return b.root == nil
}</span>

func (b *FullBinaryTree) ToVector() []int <span class="cov8" title="1">{
        result := []int{}
        b.inOrderToVector(b.root, &amp;result)
        return result
}</span>

func (b *FullBinaryTree) inOrderToVector(node *TreeNode, result *[]int) <span class="cov8" title="1">{
        if node == nil </span><span class="cov8" title="1">{
                return
        }</span>
        <span class="cov8" title="1">b.inOrderToVector(node.left, result)
        *result = append(*result, node.data)
        b.inOrderToVector(node.right, result)</span>
}

func (b *FullBinaryTree) FromVector(elements []int) <span class="cov8" title="1">{
        b.root = nil
        for _, value := range elements </span><span class="cov8" title="1">{
                b.Insert(value)
        }</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package main

import "fmt"

type DLLNode struct {
        data string
        prev *DLLNode
        next *DLLNode
}

type DoublyLinkedList struct {
        head *DLLNode
        tail *DLLNode
        size int
}

func NewDoublyLinkedList() *DoublyLinkedList <span class="cov8" title="1">{
        return &amp;DoublyLinkedList{}
}</span>

func (d *DoublyLinkedList) PushBack(value string) <span class="cov8" title="1">{
        newNode := &amp;DLLNode{data: value}
        if d.head == nil </span><span class="cov8" title="1">{
                d.head = newNode
                d.tail = newNode
        }</span> else<span class="cov8" title="1"> {
                d.tail.next = newNode
                newNode.prev = d.tail
                d.tail = newNode
        }</span>
        <span class="cov8" title="1">d.size++</span>
}

func (d *DoublyLinkedList) PushFront(value string) <span class="cov8" title="1">{
        newNode := &amp;DLLNode{data: value}
        if d.head == nil </span><span class="cov8" title="1">{
                d.head = newNode
                d.tail = newNode
        }</span> else<span class="cov8" title="1"> {
                newNode.next = d.head
                d.head.prev = newNode
                d.head = newNode
        }</span>
        <span class="cov8" title="1">d.size++</span>
}

func (d *DoublyLinkedList) PopFront() <span class="cov8" title="1">{
        if d.head == nil </span><span class="cov8" title="1">{
                return
        }</span>
        <span class="cov8" title="1">d.head = d.head.next
        if d.head != nil </span><span class="cov8" title="1">{
                d.head.prev = nil
        }</span> else<span class="cov8" title="1"> {
                d.tail = nil
        }</span>
        <span class="cov8" title="1">d.size--</span>
}

func (d *DoublyLinkedList) PopBack() <span class="cov8" title="1">{
        if d.tail == nil </span><span class="cov8" title="1">{
                return
        }</span>
        <span class="cov8" title="1">d.tail = d.tail.prev
        if d.tail != nil </span><span class="cov8" title="1">{
                d.tail.next = nil
        }</span> else<span class="cov0" title="0"> {
                d.head = nil
        }</span>
        <span class="cov8" title="1">d.size--</span>
}

func (d *DoublyLinkedList) Insert(index int, value string) <span class="cov8" title="1">{
        if index &gt; d.size </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">if index == 0 </span><span class="cov8" title="1">{
                d.PushFront(value)
                return
        }</span>
        <span class="cov8" title="1">if index == d.size </span><span class="cov8" title="1">{
                d.PushBack(value)
                return
        }</span>
        
        <span class="cov8" title="1">current := d.head
        for i := 0; i &lt; index; i++ </span><span class="cov8" title="1">{
                current = current.next
        }</span>
        
        <span class="cov8" title="1">newNode := &amp;DLLNode{data: value}
        newNode.prev = current.prev
        newNode.next = current
        current.prev.next = newNode
        current.prev = newNode
        d.size++</span>
}

func (d *DoublyLinkedList) Remove(index int) <span class="cov8" title="1">{
        if index &gt;= d.size </span><span class="cov8" title="1">{
                return
        }</span>
        <span class="cov8" title="1">if index == 0 </span><span class="cov8" title="1">{
                d.PopFront()
                return
        }</span>
        <span class="cov8" title="1">if index == d.size-1 </span><span class="cov8" title="1">{
                d.PopBack()
                return
        }</span>
        
        <span class="cov8" title="1">current := d.head
        for i := 0; i &lt; index; i++ </span><span class="cov8" title="1">{
                current = current.next
        }</span>
        
        <span class="cov8" title="1">current.prev.next = current.next
        current.next.prev = current.prev
        d.size--</span>
}

func (d *DoublyLinkedList) Get(index int) (string, error) <span class="cov8" title="1">{
        if index &gt;= d.size </span><span class="cov8" title="1">{
                return "", fmt.Errorf("index out of range")
        }</span>
        
        <span class="cov8" title="1">current := d.head
        for i := 0; i &lt; index; i++ </span><span class="cov8" title="1">{
                current = current.next
        }</span>
        <span class="cov8" title="1">return current.data, nil</span>
}

func (d *DoublyLinkedList) GetFront() (string, error) <span class="cov8" title="1">{
        if d.head == nil </span><span class="cov8" title="1">{
                return "", fmt.Errorf("list is empty")
        }</span>
        <span class="cov8" title="1">return d.head.data, nil</span>
}

func (d *DoublyLinkedList) GetBack() (string, error) <span class="cov8" title="1">{
        if d.tail == nil </span><span class="cov8" title="1">{
                return "", fmt.Errorf("list is empty")
        }</span>
        <span class="cov8" title="1">return d.tail.data, nil</span>
}

func (d *DoublyLinkedList) IsEmpty() bool <span class="cov8" title="1">{
        return d.size == 0
}</span>

func (d *DoublyLinkedList) Size() int <span class="cov8" title="1">{
        return d.size
}</span>

func (d *DoublyLinkedList) Clear() <span class="cov8" title="1">{
        for !d.IsEmpty() </span><span class="cov8" title="1">{
                d.PopFront()
        }</span>
}

func (d *DoublyLinkedList) ToVector() []string <span class="cov8" title="1">{
        result := make([]string, 0, d.size)
        current := d.head
        for current != nil </span><span class="cov8" title="1">{
                result = append(result, current.data)
                current = current.next
        }</span>
        <span class="cov8" title="1">return result</span>
}

func (d *DoublyLinkedList) FromVector(elements []string) <span class="cov8" title="1">{
        d.Clear()
        for _, element := range elements </span><span class="cov8" title="1">{
                d.PushBack(element)
        }</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package main

type Pair struct {
        key   rune
        value int
}

type OpenAddressingHashTable struct {
        table    []Pair
        occupied []bool
        capacity int
        size     int
}

func NewOpenAddressingHashTable(capacity int) *OpenAddressingHashTable <span class="cov8" title="1">{
        if capacity == 0 </span><span class="cov0" title="0">{
                capacity = 256
        }</span>
        <span class="cov8" title="1">return &amp;OpenAddressingHashTable{
                table:    make([]Pair, capacity),
                occupied: make([]bool, capacity),
                capacity: capacity,
                size:     0,
        }</span>
}

func (h *OpenAddressingHashTable) hash(key rune, attempt int) int <span class="cov8" title="1">{
        return (int(key) + attempt) % h.capacity
}</span>

func (h *OpenAddressingHashTable) Insert(key rune, value int) <span class="cov8" title="1">{
        if h.size &gt;= h.capacity </span><span class="cov0" title="0">{
                return
        }</span>
        
        <span class="cov8" title="1">for attempt := 0; attempt &lt; h.capacity; attempt++ </span><span class="cov8" title="1">{
                index := h.hash(key, attempt)
                
                if !h.occupied[index] </span><span class="cov8" title="1">{
                        h.table[index] = Pair{key, value}
                        h.occupied[index] = true
                        h.size++
                        return
                }</span>
                
                <span class="cov8" title="1">if h.occupied[index] &amp;&amp; h.table[index].key == key </span><span class="cov8" title="1">{
                        h.table[index].value = value
                        return
                }</span>
        }
}

func (h *OpenAddressingHashTable) Search(key rune) (int, bool) <span class="cov8" title="1">{
        for attempt := 0; attempt &lt; h.capacity; attempt++ </span><span class="cov8" title="1">{
                index := h.hash(key, attempt)
                
                if h.occupied[index] &amp;&amp; h.table[index].key == key </span><span class="cov8" title="1">{
                        return h.table[index].value, true
                }</span>
                
                <span class="cov8" title="1">if !h.occupied[index] </span><span class="cov8" title="1">{
                        break</span>
                }
        }
        <span class="cov8" title="1">return 0, false</span>
}

func (h *OpenAddressingHashTable) Remove(key rune) bool <span class="cov8" title="1">{
        for attempt := 0; attempt &lt; h.capacity; attempt++ </span><span class="cov8" title="1">{
                index := h.hash(key, attempt)
                
                if h.occupied[index] &amp;&amp; h.table[index].key == key </span><span class="cov8" title="1">{
                        h.occupied[index] = false
                        h.size--
                        return true
                }</span>
                
                <span class="cov8" title="1">if !h.occupied[index] </span><span class="cov8" title="1">{
                        break</span>
                }
        }
        <span class="cov8" title="1">return false</span>
}

func (h *OpenAddressingHashTable) Clear() <span class="cov8" title="1">{
        for i := 0; i &lt; h.capacity; i++ </span><span class="cov8" title="1">{
                h.occupied[i] = false
        }</span>
        <span class="cov8" title="1">h.size = 0</span>
}

func (h *OpenAddressingHashTable) IsEmpty() bool <span class="cov8" title="1">{
        return h.size == 0
}</span>

func (h *OpenAddressingHashTable) GetSize() int <span class="cov8" title="1">{
        return h.size
}</span>

func (h *OpenAddressingHashTable) ToVector() []Pair <span class="cov8" title="1">{
        result := []Pair{}
        for i := 0; i &lt; h.capacity; i++ </span><span class="cov8" title="1">{
                if h.occupied[i] </span><span class="cov8" title="1">{
                        result = append(result, h.table[i])
                }</span>
        }
        <span class="cov8" title="1">return result</span>
}

func (h *OpenAddressingHashTable) FromVector(elements []Pair) <span class="cov8" title="1">{
        h.Clear()
        for _, element := range elements </span><span class="cov8" title="1">{
                h.Insert(element.key, element.value)
        }</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package main

import (
        "bufio"
        "encoding/binary"
        "fmt"
        "os"
)

type Serializer struct{}

func NewSerializer() *Serializer <span class="cov8" title="1">{
        return &amp;Serializer{}
}</span>

// –ë–∏–Ω–∞—Ä–Ω–∞—è —Å–µ—Ä–∏–∞–ª–∏–∑–∞—Ü–∏—è Stack
func (s *Serializer) BinarySerializeStack(obj *Stack, filename string) error <span class="cov8" title="1">{
        file, err := os.Create(filename)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("cannot open file for writing: %v", err)
        }</span>
        <span class="cov8" title="1">defer file.Close()

        data := obj.ToVector()
        size := uint64(len(data))

        // –ó–∞–ø–∏—Å—ã–≤–∞–µ–º —Ä–∞–∑–º–µ—Ä
        if err := binary.Write(file, binary.LittleEndian, size); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // –ó–∞–ø–∏—Å—ã–≤–∞–µ–º –∫–∞–∂–¥—É—é —Å—Ç—Ä–æ–∫—É
        <span class="cov8" title="1">for _, str := range data </span><span class="cov8" title="1">{
                strBytes := []byte(str)
                strSize := uint64(len(strBytes))

                if err := binary.Write(file, binary.LittleEndian, strSize); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov8" title="1">if _, err := file.Write(strBytes); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}

func (s *Serializer) BinaryDeserializeStack(obj *Stack, filename string) error <span class="cov8" title="1">{
        file, err := os.Open(filename)
        if err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("cannot open file for reading: %v", err)
        }</span>
        <span class="cov8" title="1">defer file.Close()

        var size uint64
        if err := binary.Read(file, binary.LittleEndian, &amp;size); err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">data := []string{}
        for i := uint64(0); i &lt; size; i++ </span><span class="cov8" title="1">{
                var strSize uint64
                if err := binary.Read(file, binary.LittleEndian, &amp;strSize); err != nil </span><span class="cov8" title="1">{
                        return err
                }</span>

                <span class="cov8" title="1">strBytes := make([]byte, strSize)
                if _, err := file.Read(strBytes); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov8" title="1">data = append(data, string(strBytes))</span>
        }

        <span class="cov8" title="1">obj.FromVector(data)
        return nil</span>
}

// –¢–µ–∫—Å—Ç–æ–≤–∞—è —Å–µ—Ä–∏–∞–ª–∏–∑–∞—Ü–∏—è Stack
func (s *Serializer) TextSerializeStack(obj *Stack, filename string) error <span class="cov8" title="1">{
        file, err := os.Create(filename)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("cannot open file for writing: %v", err)
        }</span>
        <span class="cov8" title="1">defer file.Close()

        data := obj.ToVector()
        if _, err := fmt.Fprintf(file, "%d\n", len(data)); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">for _, str := range data </span><span class="cov8" title="1">{
                if _, err := fmt.Fprintln(file, str); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}

func (s *Serializer) TextDeserializeStack(obj *Stack, filename string) error <span class="cov8" title="1">{
        file, err := os.Open(filename)
        if err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("cannot open file for reading: %v", err)
        }</span>
        <span class="cov8" title="1">defer file.Close()

        var size int
        if _, err := fmt.Fscanf(file, "%d\n", &amp;size); err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">scanner := bufio.NewScanner(file)
        data := []string{}
        for i := 0; i &lt; size; i++ </span><span class="cov8" title="1">{
                if scanner.Scan() </span><span class="cov8" title="1">{
                        data = append(data, scanner.Text())
                }</span> else<span class="cov8" title="1"> {
                        break</span>
                }
        }

        <span class="cov8" title="1">if err := scanner.Err(); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">obj.FromVector(data)
        return nil</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package main

import "fmt"

type SLLNode struct {
        data string
        next *SLLNode
}

type SinglyLinkedList struct {
        head *SLLNode
        tail *SLLNode
        size int
}

func NewSinglyLinkedList() *SinglyLinkedList <span class="cov8" title="1">{
        return &amp;SinglyLinkedList{}
}</span>

func (s *SinglyLinkedList) PushBack(value string) <span class="cov8" title="1">{
        newNode := &amp;SLLNode{data: value}
        if s.head == nil </span><span class="cov8" title="1">{
                s.head = newNode
                s.tail = newNode
        }</span> else<span class="cov8" title="1"> {
                s.tail.next = newNode
                s.tail = newNode
        }</span>
        <span class="cov8" title="1">s.size++</span>
}

func (s *SinglyLinkedList) PushFront(value string) <span class="cov8" title="1">{
        newNode := &amp;SLLNode{data: value}
        if s.head == nil </span><span class="cov0" title="0">{
                s.head = newNode
                s.tail = newNode
        }</span> else<span class="cov8" title="1"> {
                newNode.next = s.head
                s.head = newNode
        }</span>
        <span class="cov8" title="1">s.size++</span>
}

func (s *SinglyLinkedList) PopFront() <span class="cov8" title="1">{
        if s.head == nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">s.head = s.head.next
        s.size--
        if s.head == nil </span><span class="cov8" title="1">{
                s.tail = nil
        }</span>
}

func (s *SinglyLinkedList) Insert(index int, value string) <span class="cov8" title="1">{
        if index &gt; s.size </span><span class="cov8" title="1">{
                return
        }</span>
        <span class="cov8" title="1">if index == 0 </span><span class="cov0" title="0">{
                s.PushFront(value)
                return
        }</span>
        <span class="cov8" title="1">if index == s.size </span><span class="cov0" title="0">{
                s.PushBack(value)
                return
        }</span>
        
        <span class="cov8" title="1">current := s.head
        for i := 0; i &lt; index-1; i++ </span><span class="cov8" title="1">{
                current = current.next
        }</span>
        
        <span class="cov8" title="1">newNode := &amp;SLLNode{data: value}
        newNode.next = current.next
        current.next = newNode
        s.size++</span>
}

func (s *SinglyLinkedList) Remove(index int) <span class="cov8" title="1">{
        if index &gt;= s.size </span><span class="cov8" title="1">{
                return
        }</span>
        <span class="cov8" title="1">if index == 0 </span><span class="cov8" title="1">{
                s.PopFront()
                return
        }</span>
        
        <span class="cov8" title="1">current := s.head
        for i := 0; i &lt; index-1; i++ </span><span class="cov8" title="1">{
                current = current.next
        }</span>
        
        <span class="cov8" title="1">current.next = current.next.next
        if current.next == nil </span><span class="cov8" title="1">{
                s.tail = current
        }</span>
        <span class="cov8" title="1">s.size--</span>
}

func (s *SinglyLinkedList) Get(index int) (string, error) <span class="cov8" title="1">{
        if index &gt;= s.size </span><span class="cov8" title="1">{
                return "", fmt.Errorf("index out of range")
        }</span>
        
        <span class="cov8" title="1">current := s.head
        for i := 0; i &lt; index; i++ </span><span class="cov8" title="1">{
                current = current.next
        }</span>
        <span class="cov8" title="1">return current.data, nil</span>
}

func (s *SinglyLinkedList) IsEmpty() bool <span class="cov8" title="1">{
        return s.size == 0
}</span>

func (s *SinglyLinkedList) Size() int <span class="cov8" title="1">{
        return s.size
}</span>

func (s *SinglyLinkedList) Clear() <span class="cov8" title="1">{
        for !s.IsEmpty() </span><span class="cov8" title="1">{
                s.PopFront()
        }</span>
}

func (s *SinglyLinkedList) ToVector() []string <span class="cov8" title="1">{
        result := make([]string, 0, s.size)
        current := s.head
        for current != nil </span><span class="cov8" title="1">{
                result = append(result, current.data)
                current = current.next
        }</span>
        <span class="cov8" title="1">return result</span>
}

func (s *SinglyLinkedList) FromVector(elements []string) <span class="cov8" title="1">{
        s.Clear()
        for _, element := range elements </span><span class="cov8" title="1">{
                s.PushBack(element)
        }</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package main

import "fmt"

type Array struct {
        arr    []string
        volume int
}

func NewArray() *Array <span class="cov8" title="1">{
        return &amp;Array{
                arr:    make([]string, 0, 10),
                volume: 10,
        }
}</span>

func (a *Array) ShowArray() <span class="cov8" title="1">{
        for i := 0; i &lt; len(a.arr); i++ </span><span class="cov0" title="0">{
                fmt.Print(a.arr[i], " ")
        }</span>
        <span class="cov8" title="1">fmt.Println()</span>
}

func (a *Array) AddToEnd(value string) <span class="cov8" title="1">{
        if len(a.arr) &gt;= a.volume </span><span class="cov8" title="1">{
                a.volume *= 2
                newArr := make([]string, len(a.arr), a.volume)
                copy(newArr, a.arr)
                a.arr = newArr
        }</span>
        <span class="cov8" title="1">a.arr = append(a.arr, value)</span>
}

func (a *Array) Add(index int, value string) <span class="cov8" title="1">{
        if index &gt; len(a.arr) </span><span class="cov8" title="1">{
                return
        }</span>
        <span class="cov8" title="1">a.arr = append(a.arr[:index], append([]string{value}, a.arr[index:]...)...)</span>
}

func (a *Array) GetIndex(index int) (string, error) <span class="cov8" title="1">{
        if index &gt;= len(a.arr) </span><span class="cov8" title="1">{
                return "", fmt.Errorf("index out of range")
        }</span>
        <span class="cov8" title="1">return a.arr[index], nil</span>
}

func (a *Array) Remove(index int) <span class="cov8" title="1">{
        if index &gt;= len(a.arr) </span><span class="cov8" title="1">{
                return
        }</span>
        <span class="cov8" title="1">a.arr = append(a.arr[:index], a.arr[index+1:]...)</span>
}

func (a *Array) Replace(index int, value string) <span class="cov8" title="1">{
        if index &gt;= len(a.arr) </span><span class="cov8" title="1">{
                return
        }</span>
        <span class="cov8" title="1">a.arr[index] = value</span>
}

func (a *Array) GetSize() int <span class="cov8" title="1">{
        return len(a.arr)
}</span>

func (a *Array) ToVector() []string <span class="cov8" title="1">{
        result := make([]string, len(a.arr))
        copy(result, a.arr)
        return result
}</span>

func (a *Array) FromVector(elements []string) <span class="cov8" title="1">{
        a.volume = len(elements) + 10
        a.arr = make([]string, len(elements))
        copy(a.arr, elements)
}</span>
</pre>
		
		<pre class="file" id="file6" style="display: none">package main

import (
        "fmt"
        "os"
)

func demoStack() <span class="cov0" title="0">{
        fmt.Println("=== Stack Demo ===")
        stack := NewStack(5)

        stack.Push("first")
        stack.Push("second")
        stack.Push("third")

        fmt.Printf("Stack size: %d\n", stack.Size())
        top, _ := stack.Peek()
        fmt.Printf("Top element: %s\n", top)

        for !stack.IsEmpty() </span><span class="cov0" title="0">{
                popped, _ := stack.Pop()
                fmt.Printf("Popped: %s\n", popped)
        }</span>
        <span class="cov0" title="0">fmt.Println()</span>
}

func demoArray() <span class="cov0" title="0">{
        fmt.Println("=== Array Demo ===")
        arr := NewArray()

        arr.AddToEnd("apple")
        arr.AddToEnd("banana")
        arr.AddToEnd("cherry")
        arr.Add(1, "blueberry")

        fmt.Print("Array contents: ")
        arr.ShowArray()
        fmt.Printf("Array size: %d\n\n", arr.GetSize())
}</span>

func demoSinglyLinkedList() <span class="cov0" title="0">{
        fmt.Println("=== Singly Linked List Demo ===")
        list := NewSinglyLinkedList()

        list.PushBack("first")
        list.PushBack("third")
        list.Insert(1, "second")

        fmt.Print("List contents: ")
        for i := 0; i &lt; list.Size(); i++ </span><span class="cov0" title="0">{
                val, _ := list.Get(i)
                fmt.Printf("%s ", val)
        }</span>
        <span class="cov0" title="0">fmt.Printf("\nList size: %d\n\n", list.Size())</span>
}

func demoDoublyLinkedList() <span class="cov0" title="0">{
        fmt.Println("=== Doubly Linked List Demo ===")
        list := NewDoublyLinkedList()

        list.PushBack("first")
        list.PushFront("very_first")
        list.PushBack("last")
        list.Insert(2, "middle")

        fmt.Print("List contents: ")
        for i := 0; i &lt; list.Size(); i++ </span><span class="cov0" title="0">{
                val, _ := list.Get(i)
                fmt.Printf("%s ", val)
        }</span>
        <span class="cov0" title="0">fmt.Printf("\nList size: %d\n", list.Size())
        
        front, _ := list.GetFront()
        back, _ := list.GetBack()
        fmt.Printf("Front: %s, Back: %s\n\n", front, back)</span>
}

func demoBinaryTree() <span class="cov0" title="0">{
        fmt.Println("=== Binary Tree Demo ===")
        tree := NewFullBinaryTree()

        tree.Insert(5)
        tree.Insert(3)
        tree.Insert(7)
        tree.Insert(1)
        tree.Insert(4)
        tree.Insert(6)
        tree.Insert(8)

        fmt.Println("Tree structure:")
        tree.Print()

        fmt.Println("Zigzag traversal:")
        tree.PrintZigZag()
        fmt.Println()
}</span>

func demoHashTable() <span class="cov0" title="0">{
        fmt.Println("=== Hash Table Demo ===")
        ht := NewOpenAddressingHashTable(10)

        ht.Insert('a', 1)
        ht.Insert('b', 2)
        ht.Insert('c', 3)

        if value, found := ht.Search('b'); found </span><span class="cov0" title="0">{
                fmt.Printf("Found 'b': %d\n", value)
        }</span>

        <span class="cov0" title="0">ht.Remove('a')
        fmt.Printf("Hash table size: %d\n\n", ht.GetSize())</span>
}

func demoSerialization() <span class="cov0" title="0">{
        fmt.Println("=== Serialization Demo ===")
        stack := NewStack(5)
        stack.Push("hello")
        stack.Push("world")

        serializer := NewSerializer()
        
        // –ë–∏–Ω–∞—Ä–Ω–∞—è —Å–µ—Ä–∏–∞–ª–∏–∑–∞—Ü–∏—è
        serializer.BinarySerializeStack(stack, "test_binary.dat")
        stack2 := NewStack(5)
        serializer.BinaryDeserializeStack(stack2, "test_binary.dat")
        
        fmt.Printf("Binary deserialized stack size: %d\n", stack2.Size())
        
        // –¢–µ–∫—Å—Ç–æ–≤–∞—è —Å–µ—Ä–∏–∞–ª–∏–∑–∞—Ü–∏—è
        serializer.TextSerializeStack(stack, "test_text.txt")
        stack3 := NewStack(5)
        serializer.TextDeserializeStack(stack3, "test_text.txt")
        
        fmt.Printf("Text deserialized stack size: %d\n\n", stack3.Size())
        
        // –û—á–∏—Å—Ç–∫–∞
        os.Remove("test_binary.dat")
        os.Remove("test_text.txt")
}</span>

func main() <span class="cov0" title="0">{
        fmt.Println("üöÄ Go Data Structures Demo")

        demoStack()
        demoArray()
        demoSinglyLinkedList()
        demoDoublyLinkedList()
        demoBinaryTree()
        demoHashTable()
        demoSerialization()

        fmt.Println("‚úÖ All demos completed successfully!")
}</span>
</pre>
		
		<pre class="file" id="file7" style="display: none">package main

import "errors"

type Stack struct {
        data     []string
        capacity int
}

func NewStack(capacity int) *Stack <span class="cov8" title="1">{
        return &amp;Stack{
                data:     make([]string, 0, capacity),
                capacity: capacity,
        }
}</span>

func (s *Stack) Push(value string) error <span class="cov8" title="1">{
        if len(s.data) &gt;= s.capacity </span><span class="cov0" title="0">{
                return errors.New("stack is full")
        }</span>
        <span class="cov8" title="1">s.data = append(s.data, value)
        return nil</span>
}

func (s *Stack) Pop() (string, error) <span class="cov8" title="1">{
        if len(s.data) == 0 </span><span class="cov0" title="0">{
                return "", errors.New("stack is empty")
        }</span>
        <span class="cov8" title="1">value := s.data[len(s.data)-1]
        s.data = s.data[:len(s.data)-1]
        return value, nil</span>
}

func (s *Stack) Peek() (string, error) <span class="cov8" title="1">{
        if len(s.data) == 0 </span><span class="cov0" title="0">{
                return "", errors.New("stack is empty")
        }</span>
        <span class="cov8" title="1">return s.data[len(s.data)-1], nil</span>
}

func (s *Stack) IsEmpty() bool <span class="cov8" title="1">{
        return len(s.data) == 0
}</span>

func (s *Stack) Size() int <span class="cov8" title="1">{
        return len(s.data)
}</span>

func (s *Stack) ToVector() []string <span class="cov8" title="1">{
        result := make([]string, len(s.data))
        copy(result, s.data)
        return result
}</span>

func (s *Stack) FromVector(elements []string) <span class="cov8" title="1">{
        s.data = make([]string, 0, len(elements)+10)
        s.capacity = len(elements) + 10
        for _, element := range elements </span><span class="cov8" title="1">{
                s.data = append(s.data, element)
        }</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
